// client/src/clashmenu/battle/BattlePanel.js - PANEL BATAILLE COMPLET AVEC MATCHMAKING
import BasePanel from '../core/BasePanel.js';

export default class BattlePanel extends BasePanel {
    constructor(scene, config = {}) {
        super(scene, {
            name: 'BattlePanel',
            title: 'BATAILLE !!!',
            icon: '‚öîÔ∏è',
            contentStartY: 120, // Plus haut pour inclure l'ar√®ne
            ...config
        });
        
        // √âtat sp√©cifique au panel bataille
        this.battleState = {
            isSearching: false,
            searchStartTime: null,
            matchData: null,
            arenaInfo: null,
            globalStats: { totalPlayers: 0, playersOnline: 0 },
            isMatchmaking: false // üÜï √âtat matchmaking
        };
        
        // √âl√©ments UI sp√©cifiques
        this.battleElements = {
            arena: null,
            battleButton: null,
            matchmakingButton: null, // üÜï Bouton matchmaking
            searchTimer: null,
            onlineCounter: null,
            leaderboard: null
        };
        
        // R√©f√©rences pour mise √† jour temps r√©el
        this.realtimeElements = {
            trophyText: null,
            arenaName: null,
            progressBar: null,
            connectionStatus: null
        };
        
        // üÜï √âl√©ments matchmaking
        this.matchmakingElements = null;
        
        // Configuration ar√®ne
        this.arenaConfig = this.getArenaConfiguration();
        
        this.log('Panel Bataille initialis√© avec Matchmaking');
    }

    // === IMPL√âMENTATION BASEPANEL ===
    
    /**
     * Cr√©er le contenu sp√©cifique du panel bataille
     */
    createContent() {
        this.log('Cr√©ation contenu bataille...');
        
        // 1. Section Ar√®ne (en haut)
        this.createArenaSection();
        
        // 2. Boutons de bataille (centre) - AVEC MATCHMAKING
        this.createBattleButtons();
        
        // 3. Statistiques et info (bas)
        this.createStatsSection();
        
        // 4. Int√©gration Colyseus
        this.setupColyseusIntegration();
        
        this.log('Contenu bataille cr√©√© avec Matchmaking', 'success');
    }
    
    /**
     * Rafra√Æchir les donn√©es du panel
     */
    refresh() {
        super.refresh();
        
        this.log('Rafra√Æchissement donn√©es bataille...');
        
        // Mettre √† jour les infos d'ar√®ne
        this.updateArenaInfo();
        
        // Mettre √† jour les statistiques
        this.updateBattleStats();
        
        // Mettre √† jour l'√©tat des boutons
        this.updateButtonStates();
    }
    
    /**
     * G√©rer les actions sp√©cifiques au panel bataille
     */
    handleAction(action, data) {
        this.log(`Action bataille: ${action}`, 'info');
        
        switch (action) {
            case 'battle':
                this.handleBattleRequest();
                break;
            case 'cancel_search':
                this.handleCancelSearch();
                break;
            case 'training':
                this.handleTraining();
                break;
            case 'tournament':
                this.handleTournament();
                break;
            case 'leaderboard':
                this.handleLeaderboard();
                break;
            case 'spectate':
                this.handleSpectate();
                break;
            // üÜï NOUVEAU HANDLER MATCHMAKING
            case 'matchmaking':
                this.handleMatchmaking();
                break;
            case 'cancel_matchmaking':
                this.handleCancelMatchmaking();
                break;
            default:
                super.handleAction(action, data);
        }
    }

    // === SECTION AR√àNE ===
    
    /**
     * Cr√©er la section d'affichage de l'ar√®ne
     */
    createArenaSection() {
        const arenaContainer = this.scene.add.container(0, 0);
        
        // Fond ar√®ne
        const arenaBg = this.createArenaBackground();
        
        // Infos ar√®ne
        const arenaInfo = this.createArenaInfo();
        
        // Barre de progression
        const progressSection = this.createProgressSection();
        
        // Statut connexion
        const connectionInfo = this.createConnectionInfo();
        
        arenaContainer.add([arenaBg, arenaInfo, progressSection, connectionInfo]);
        
        this.battleElements.arena = arenaContainer;
        this.elements.content.add(arenaContainer);
    }
    
    /**
     * Cr√©er le fond stylis√© de l'ar√®ne
     */
    createArenaBackground() {
        const bg = this.createGraphics();
        
        // Panel principal avec d√©grad√©
        bg.fillGradientStyle(
            0x2F4F4F, 0x2F4F4F,
            0x1C3A3A, 0x1C3A3A,
            1
        );
        bg.fillRoundedRect(20, 0, this.width - 40, 140, 15);
        
        // Bordure dor√©e √©paisse
        bg.lineStyle(4, 0xFFD700, 1);
        bg.strokeRoundedRect(20, 0, this.width - 40, 140, 15);
        
        // Effet de brillance
        const shine = this.createGraphics();
        shine.fillGradientStyle(
            0xFFFFFF, 0xFFFFFF,
            0xFFFFFF, 0xFFFFFF,
            0.4, 0.1
        );
        shine.fillRoundedRect(25, 5, this.width - 50, 25, 10);
        
        return [bg, shine];
    }
    
    /**
     * Cr√©er les informations de l'ar√®ne
     */
    createArenaInfo() {
        const currentArena = this.getCurrentArena();
        
        // Nom de l'ar√®ne
        this.realtimeElements.arenaName = this.createText(
            this.width / 2, 30,
            currentArena.name,
            {
                fontSize: this.isMobile ? '18px' : '22px',
                fontWeight: 'bold',
                fill: '#FFD700',
                stroke: '#8B4513',
                strokeThickness: 2
            }
        );
        this.realtimeElements.arenaName.setOrigin(0.5);
        
        // Niveau d'ar√®ne
        const arenaLevel = this.createText(
            this.width / 2, 55,
            currentArena.displayName,
            {
                fontSize: this.isMobile ? '14px' : '16px',
                fontWeight: 'bold',
                fill: '#B0C4DE',
                stroke: '#2F4F4F',
                strokeThickness: 1
            }
        );
        arenaLevel.setOrigin(0.5);
        
        return [this.realtimeElements.arenaName, arenaLevel];
    }
    
    /**
     * Cr√©er la section de progression
     */
    createProgressSection() {
        const currentTrophies = this.getUserData()?.playerStats?.trophies || 0;
        const currentArena = this.getCurrentArena();
        const nextArena = this.getNextArena();
        
        // Texte des troph√©es
        const progressText = nextArena ? 
            `üèÜ ${currentTrophies}/${nextArena.minTrophies}` :
            `üèÜ ${currentTrophies} MAX`;
            
        this.realtimeElements.trophyText = this.createText(
            this.width / 2, 85,
            progressText,
            {
                fontSize: this.isMobile ? '13px' : '15px',
                fontWeight: 'bold',
                fill: '#FFD700',
                stroke: '#8B4513',
                strokeThickness: 1
            }
        );
        this.realtimeElements.trophyText.setOrigin(0.5);
        
        // Barre de progression
        const progressBar = this.createProgressBar(currentTrophies, currentArena, nextArena);
        
        return [this.realtimeElements.trophyText, progressBar];
    }
    
    /**
     * Cr√©er la barre de progression des troph√©es
     */
    createProgressBar(currentTrophies, currentArena, nextArena) {
        const barX = this.width / 2 - 100;
        const barY = 105;
        const barWidth = 200;
        const barHeight = 12;
        
        // Fond de la barre
        const progressBg = this.createGraphics();
        progressBg.fillStyle(0x2F2F2F, 0.8);
        progressBg.fillRoundedRect(barX, barY, barWidth, barHeight, 6);
        progressBg.lineStyle(2, 0x555555);
        progressBg.strokeRoundedRect(barX, barY, barWidth, barHeight, 6);
        
        // Barre de progression
        this.realtimeElements.progressBar = this.createGraphics();
        
        if (nextArena) {
            const progressInArena = currentTrophies - currentArena.minTrophies;
            const totalArenaRange = nextArena.minTrophies - currentArena.minTrophies;
            const progressPercent = Math.min((progressInArena / totalArenaRange) * 100, 100);
            
            this.realtimeElements.progressBar.fillStyle(0xFFD700, 1);
            this.realtimeElements.progressBar.fillRoundedRect(
                barX + 2, barY + 2,
                Math.max(0, (barWidth - 4) * progressPercent / 100),
                barHeight - 4,
                4
            );
            
            // Effet brillance
            const progressShine = this.createGraphics();
            progressShine.fillGradientStyle(
                0xFFFFFF, 0xFFFFFF,
                0xFFFFFF, 0xFFFFFF,
                0.6, 0.2
            );
            progressShine.fillRoundedRect(
                barX + 2, barY + 2,
                Math.max(0, (barWidth - 4) * progressPercent / 100),
                (barHeight - 4) / 2,
                2
            );
            
            return [progressBg, this.realtimeElements.progressBar, progressShine];
        } else {
            // Ar√®ne max
            this.realtimeElements.progressBar.fillStyle(0x9370DB, 1);
            this.realtimeElements.progressBar.fillRoundedRect(
                barX + 2, barY + 2,
                barWidth - 4,
                barHeight - 4,
                4
            );
            
            return [progressBg, this.realtimeElements.progressBar];
        }
    }
    
    /**
     * Cr√©er les informations de connexion
     */
    createConnectionInfo() {
        // Indicateur de connexion
        this.realtimeElements.connectionStatus = this.createText(
            this.width - 30, 20,
            'üî¥',
            { fontSize: '16px' }
        );
        this.realtimeElements.connectionStatus.setOrigin(1, 0);
        
        // Compteur joueurs en ligne
        this.battleElements.onlineCounter = this.createText(
            this.width - 30, 45,
            'üë• ? en ligne',
            {
                fontSize: this.isMobile ? '10px' : '12px',
                fill: '#B0C4DE'
            }
        );
        this.battleElements.onlineCounter.setOrigin(1, 0);
        
        return [this.realtimeElements.connectionStatus, this.battleElements.onlineCounter];
    }

    // === BOUTONS DE BATAILLE AVEC MATCHMAKING ===
    
    /**
     * Cr√©er les boutons de bataille - AVEC MATCHMAKING
     */
    createBattleButtons() {
        const buttonsContainer = this.scene.add.container(0, 160);
        
        // Bouton principal BATAILLE
        this.battleElements.battleButton = this.createBattleMainButton();
        
        // üÜï BOUTON MATCHMAKING PRINCIPAL
        this.battleElements.matchmakingButton = this.createButton(
            this.width / 2, 90, // Position sous le bouton principal
            220, 60,           // Plus large et plus haut
            'üéØ MATCHMAKING',
            '#FF6347',         // Rouge-orange distinctif
            () => this.safeAction('matchmaking')
        );
        
        // Effet sp√©cial pour le bouton matchmaking
        this.addMatchmakingButtonEffects();
        
        // Boutons secondaires (repositionn√©s plus bas)
        const trainingButton = this.createButton(
            this.width / 2 - 80, 170, // D√©cal√© vers le bas
            140, 50,
            'üéØ Entra√Ænement',
            '#32CD32',
            () => this.safeAction('training')
        );
        
        const tournamentButton = this.createButton(
            this.width / 2 + 80, 170,
            140, 50,
            'üèÜ Tournoi',
            '#9370DB',
            () => this.safeAction('tournament')
        );
        
        // Boutons tertiaires (repositionn√©s encore plus bas)
        const leaderboardButton = this.createButton(
            this.width / 2 - 80, 230,
            140, 40,
            'üìä Classement',
            '#4682B4',
            () => this.safeAction('leaderboard')
        );
        
        const spectateButton = this.createButton(
            this.width / 2 + 80, 230,
            140, 40,
            'üëÅÔ∏è Observer',
            '#708090',
            () => this.safeAction('spectate')
        );
        
        buttonsContainer.add([
            this.battleElements.battleButton,
            this.battleElements.matchmakingButton, // üÜï AJOUT√â ICI
            trainingButton,
            tournamentButton,
            leaderboardButton,
            spectateButton
        ]);
        
        this.elements.content.add(buttonsContainer);
    }
    
    /**
     * Cr√©er le bouton principal de bataille
     */
    createBattleMainButton() {
        const buttonText = this.battleState.isSearching ? '‚ùå ANNULER' : '‚öîÔ∏è BATAILLE';
        const buttonColor = this.battleState.isSearching ? '#DC143C' : '#FFD700';
        
        const button = this.createButton(
            this.width / 2, 30,
            220, 70,
            buttonText,
            buttonColor,
            () => {
                if (this.battleState.isSearching) {
                    this.safeAction('cancel_search');
                } else {
                    this.safeAction('battle');
                }
            }
        );
        
        // Animation pulsante si en recherche
        if (this.battleState.isSearching) {
            this.scene.tweens.add({
                targets: button,
                scaleX: 1.05,
                scaleY: 1.05,
                duration: 1000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
        }
        
        return button;
    }
    
    // üÜï EFFETS SP√âCIAUX BOUTON MATCHMAKING
    /**
     * Ajouter des effets visuels au bouton matchmaking
     */
    addMatchmakingButtonEffects() {
        if (!this.battleElements.matchmakingButton) return;
        
        // Effet de pulsation continue
        this.scene.tweens.add({
            targets: this.battleElements.matchmakingButton,
            scaleX: 1.03,
            scaleY: 1.03,
            duration: 2000,
            yoyo: true,
            repeat: -1,
            ease: 'Sine.easeInOut'
        });
        
        // Effet de brillance p√©riodique
        this.scene.time.addEvent({
            delay: 3000,
            callback: () => {
                if (this.battleElements.matchmakingButton) {
                    this.createMatchmakingGlow();
                }
            },
            repeat: -1
        });
    }
    
    /**
     * Cr√©er effet de brillance pour le bouton matchmaking
     */
    createMatchmakingGlow() {
        const glow = this.createGraphics();
        glow.fillStyle(0xFF6347, 0.3);
        glow.fillRoundedRect(
            this.width / 2 - 115, 85,
            230, 70, 12
        );
        
        // Animation de fade
        this.scene.tweens.add({
            targets: glow,
            alpha: 0,
            scaleX: 1.2,
            scaleY: 1.2,
            duration: 1000,
            ease: 'Power2.easeOut',
            onComplete: () => glow.destroy()
        });
    }

    // === SECTION STATISTIQUES ===
    
    /**
     * Cr√©er la section des statistiques
     */
    createStatsSection() {
        if (this.isMobile) return; // Pas d'stats sur mobile pour √©conomiser l'espace
        
        const statsContainer = this.scene.add.container(0, 320);
        
        // Fond des stats
        const statsBg = this.createGraphics();
        statsBg.fillStyle(0x1C3A3A, 0.8);
        statsBg.fillRoundedRect(30, 0, this.width - 60, 80, 8);
        statsBg.lineStyle(1, 0x4682B4);
        statsBg.strokeRoundedRect(30, 0, this.width - 60, 80, 8);
        statsContainer.add(statsBg);
        
        // Titre stats
        const statsTitle = this.createText(
            this.width / 2, 15,
            'üìä Vos statistiques de bataille',
            {
                fontSize: '14px',
                fontWeight: 'bold',
                fill: '#FFD700'
            },
            statsContainer
        );
        statsTitle.setOrigin(0.5);
        
        // Stats en ligne
        this.createBattleStatsDisplay(statsContainer);
        
        this.elements.content.add(statsContainer);
    }
    
    /**
     * Afficher les statistiques de bataille
     */
    createBattleStatsDisplay(container) {
        const userData = this.getUserData();
        const wins = userData?.gameStats?.wins || 0;
        const losses = userData?.gameStats?.losses || 0;
        const winRate = userData?.winRate || 0;
        const winStreak = userData?.gameStats?.winStreak || 0;
        
        const statsText = this.createText(
            this.width / 2, 45,
            `‚úÖ ${wins} victoires  ‚Ä¢  ‚ùå ${losses} d√©faites  ‚Ä¢  üìà ${winRate}% r√©ussite  ‚Ä¢  üî• ${winStreak} s√©rie`,
            {
                fontSize: '12px',
                fill: '#B0C4DE'
            },
            container
        );
        statsText.setOrigin(0.5);
        
        // Timer de recherche si en cours
        if (this.battleState.isSearching) {
            this.createSearchTimer(container);
        }
    }
    
    /**
     * Cr√©er le timer de recherche
     */
    createSearchTimer(container) {
        this.battleElements.searchTimer = this.createText(
            this.width / 2, 65,
            '‚è±Ô∏è Recherche: 0:00',
            {
                fontSize: '12px',
                fontWeight: 'bold',
                fill: '#FF6347'
            },
            container
        );
        this.battleElements.searchTimer.setOrigin(0.5);
        
        // Mettre √† jour le timer chaque seconde
        this.searchTimerInterval = setInterval(() => {
            this.updateSearchTimer();
        }, 1000);
    }

    // === HANDLERS D'ACTIONS ===
    
    /**
     * G√©rer la demande de bataille
     */
    handleBattleRequest() {
        this.log('Demande de bataille...');
        
        // V√©rifier les pr√©requis
        if (this.battleState.isSearching) {
            this.log('Recherche d√©j√† en cours', 'warn');
            return;
        }
        
        // V√©rifier la connexion
        if (!this.isColyseusConnected()) {
            this.showError('Connexion au serveur requise pour jouer');
            return;
        }
        
        // Lancer la recherche (via callback parent)
        super.handleAction('battle', {
            trophies: this.getUserData()?.playerStats?.trophies || 0,
            level: this.getUserData()?.playerStats?.level || 1
        });
    }
    
    /**
     * G√©rer l'annulation de recherche
     */
    handleCancelSearch() {
        this.log('Annulation recherche...');
        
        if (!this.battleState.isSearching) {
            this.log('Aucune recherche en cours', 'warn');
            return;
        }
        
        // Annuler la recherche (via callback parent)
        super.handleAction('cancel_search');
    }
    
    // üÜï HANDLERS MATCHMAKING
    
    /**
     * G√©rer le matchmaking avanc√©
     */
    handleMatchmaking() {
        this.log('Matchmaking avanc√© demand√©');
        
        // V√©rifier les pr√©requis
        if (this.battleState.isSearching || this.battleState.isMatchmaking) {
            this.log('Recherche ou matchmaking d√©j√† en cours', 'warn');
            this.showError('Une recherche est d√©j√† en cours');
            return;
        }
        
        // V√©rifier la connexion
        if (!this.isColyseusConnected()) {
            this.showError('Connexion au serveur requise pour le matchmaking');
            return;
        }
        
        // Marquer comme actif
        this.battleState.isMatchmaking = true;
        
        // Donn√©es du joueur pour le matchmaking
        const playerData = {
            trophies: this.getUserData()?.playerStats?.trophies || 0,
            level: this.getUserData()?.playerStats?.level || 1,
            winRate: this.getUserData()?.winRate || 0,
            preferredGameMode: 'ranked', // Ou 'casual', 'tournament'
            region: 'EU', // √Ä adapter selon la localisation
            deck: this.getUserData()?.currentDeck || [],
            timestamp: Date.now()
        };
        
        this.log('Lancement matchmaking avec donn√©es:', playerData);
        
        // Envoyer l'action au PanelManager puis √† ClashMenuScene
        super.handleAction('matchmaking', {
            type: 'advanced_matchmaking',
            playerData: playerData,
            timestamp: Date.now()
        });
        
        // Interface utilisateur
        this.showMatchmakingUI();
    }
    
    /**
     * G√©rer l'annulation du matchmaking
     */
    handleCancelMatchmaking() {
        this.log('Annulation matchmaking avanc√©');
        
        // Marquer comme inactif
        this.battleState.isMatchmaking = false;
        
        // Envoyer annulation au serveur
        super.handleAction('cancel_matchmaking', {
            type: 'advanced_matchmaking',
            timestamp: Date.now()
        });
        
        this.cleanupMatchmakingUI();
    }
    
    /**
     * G√©rer l'entra√Ænement
     */
    handleTraining() {
        this.log('Mode entra√Ænement demand√©');
        super.handleAction('training');
    }
    
    /**
     * G√©rer les tournois
     */
    handleTournament() {
        this.log('Tournois demand√©s');
        super.handleAction('tournament');
    }
    
    /**
     * G√©rer le classement
     */
    handleLeaderboard() {
        this.log('Classement demand√©');
        super.handleAction('leaderboard');
    }
    
    /**
     * G√©rer l'observation
     */
    handleSpectate() {
        this.log('Mode spectateur demand√©');
        super.handleAction('spectate');
    }

    // === INTERFACE MATCHMAKING ===
    
    /**
     * Afficher l'interface de matchmaking
     */
    showMatchmakingUI() {
        // Cr√©er overlay de matchmaking
        this.createMatchmakingOverlay();
        
        // Notification
        if (this.scene.showMessage) {
            this.scene.showMessage('üéØ Recherche de match avanc√©e...', 'info');
        }
    }
    
    /**
     * Cr√©er l'overlay de matchmaking
     */
    createMatchmakingOverlay() {
        // Overlay semi-transparent
        const overlay = this.createGraphics();
        overlay.fillStyle(0x000000, 0.7);
        overlay.fillRect(0, 0, this.width, this.height);
        overlay.setDepth(1000);
        
        // Panel de matchmaking
        const panelWidth = Math.min(this.width - 40, 320);
        const panelHeight = 220;
        
        const matchmakingPanel = this.createGraphics();
        matchmakingPanel.fillStyle(0x2F4F4F, 1);
        matchmakingPanel.fillRoundedRect(
            this.width/2 - panelWidth/2, this.height/2 - panelHeight/2,
            panelWidth, panelHeight, 15
        );
        matchmakingPanel.lineStyle(3, 0xFF6347); // Couleur matchmaking
        matchmakingPanel.strokeRoundedRect(
            this.width/2 - panelWidth/2, this.height/2 - panelHeight/2,
            panelWidth, panelHeight, 15
        );
        matchmakingPanel.setDepth(1001);
        
        // Titre
        const title = this.createText(
            this.width/2, this.height/2 - 70,
            'üéØ MATCHMAKING AVANC√â',
            {
                fontSize: '18px',
                fontWeight: 'bold',
                fill: '#FF6347'
            }
        );
        title.setOrigin(0.5);
        title.setDepth(1002);
        
        // Statut
        const status = this.createText(
            this.width/2, this.height/2 - 30,
            'Recherche de joueurs compatibles...\nAnalyse du niveau et des troph√©es\nEstimation du temps d\'attente',
            {
                fontSize: '12px',
                fill: '#B0C4DE',
                align: 'center'
            }
        );
        status.setOrigin(0.5);
        status.setDepth(1002);
        
        // Animation de recherche
        const spinner = this.createText(
            this.width/2, this.height/2 + 20,
            '‚ö°',
            { fontSize: '28px' }
        );
        spinner.setOrigin(0.5);
        spinner.setDepth(1002);
        
        // Animation rotation
        this.scene.tweens.add({
            targets: spinner,
            rotation: Math.PI * 2,
            duration: 1000,
            repeat: -1,
            ease: 'Linear'
        });
        
        // Compteur de temps
        const timeCounter = this.createText(
            this.width/2, this.height/2 + 50,
            'Temps √©coul√©: 0s',
            {
                fontSize: '11px',
                fill: '#FFD700'
            }
        );
        timeCounter.setOrigin(0.5);
        timeCounter.setDepth(1002);
        
        // Bouton annuler
        const cancelButton = this.createButton(
            this.width/2, this.height/2 + 80,
            140, 35,
            '‚ùå Annuler',
            '#DC143C',
            () => {
                this.safeAction('cancel_matchmaking');
            }
        );
        cancelButton.setDepth(1002);
        
        // Stocker les r√©f√©rences pour nettoyage
        this.matchmakingElements = {
            overlay, matchmakingPanel, title, status, spinner, timeCounter, cancelButton,
            startTime: Date.now()
        };
        
        // Mettre √† jour le compteur de temps
        this.matchmakingTimeInterval = setInterval(() => {
            this.updateMatchmakingTimer();
        }, 1000);
        
        // Auto-fermeture apr√®s 60 secondes
        this.scene.time.delayedCall(60000, () => {
            if (this.battleState.isMatchmaking) {
                this.handleCancelMatchmaking();
            }
        });
    }
    
    /**
     * Mettre √† jour le timer de matchmaking
     */
    updateMatchmakingTimer() {
        if (!this.matchmakingElements || !this.matchmakingElements.timeCounter) {
            return;
        }
        
        const elapsed = Math.floor((Date.now() - this.matchmakingElements.startTime) / 1000);
        this.matchmakingElements.timeCounter.setText(`Temps √©coul√©: ${elapsed}s`);
    }
    
    /**
     * Nettoyer l'interface de matchmaking
     */
    cleanupMatchmakingUI() {
        // Nettoyer le timer
        if (this.matchmakingTimeInterval) {
            clearInterval(this.matchmakingTimeInterval);
            this.matchmakingTimeInterval = null;
        }
        
        // Nettoyer les √©l√©ments visuels
        if (this.matchmakingElements) {
            Object.values(this.matchmakingElements).forEach(element => {
                if (element && element.destroy) {
                    element.destroy();
                }
            });
            this.matchmakingElements = null;
        }
        
        // R√©initialiser l'√©tat
        this.battleState.isMatchmaking = false;
    }

    // === INT√âGRATION COLYSEUS ===
    
    /**
     * Configurer l'int√©gration Colyseus
     */
    setupColyseusIntegration() {
        this.log('Configuration int√©gration Colyseus...');
        
        // Ces callbacks seront connect√©s par la sc√®ne parent
        // Via this.config.onAction qui remontera √† ClashMenuScene
        
        // Pour l'instant, on simule juste les callbacks
        this.simulateColyseusCallbacks();
    }
    
    /**
     * Simuler les callbacks Colyseus (en attendant la vraie int√©gration)
     */
    simulateColyseusCallbacks() {
        // Simuler connexion apr√®s 2 secondes
        setTimeout(() => {
            this.onColyseusConnected();
        }, 2000);
        
        // Simuler mise √† jour stats globales
        setTimeout(() => {
            this.onGlobalStatsUpdated({
                totalPlayers: 1247,
                playersOnline: 89,
                playersSearching: 12
            });
        }, 3000);
    }

    // === CALLBACKS COLYSEUS ===
    
    /**
     * Callback connexion Colyseus √©tablie
     */
    onColyseusConnected() {
        this.log('Colyseus connect√©', 'success');
        
        if (this.realtimeElements.connectionStatus) {
            this.realtimeElements.connectionStatus.setText('üü¢');
        }
    }
    
    /**
     * Callback d√©connexion Colyseus
     */
    onColyseusDisconnected() {
        this.log('Colyseus d√©connect√©', 'warn');
        
        if (this.realtimeElements.connectionStatus) {
            this.realtimeElements.connectionStatus.setText('üî¥');
        }
        
        if (this.battleElements.onlineCounter) {
            this.battleElements.onlineCounter.setText('üë• Hors ligne');
        }
    }
    
    /**
     * Callback mise √† jour statistiques globales
     */
    onGlobalStatsUpdated(stats) {
        this.battleState.globalStats = stats;
        
        if (this.battleElements.onlineCounter) {
            this.battleElements.onlineCounter.setText(`üë• ${stats.playersOnline} en ligne`);
        }
        
        this.log(`Stats globales: ${stats.playersOnline} joueurs en ligne`);
    }
    
    /**
     * Callback recherche de bataille commenc√©e
     */
    onSearchStarted(data) {
        this.battleState.isSearching = true;
        this.battleState.searchStartTime = Date.now();
        
        this.updateBattleButton();
        this.createSearchTimer(this.elements.content);
        
        this.log('Recherche de bataille commenc√©e', 'info');
    }
    
    /**
     * Callback recherche annul√©e
     */
    onSearchCancelled(data) {
        this.battleState.isSearching = false;
        this.battleState.searchStartTime = null;
        
        this.updateBattleButton();
        this.clearSearchTimer();
        
        this.log('Recherche de bataille annul√©e', 'info');
    }
    
    /**
     * Callback match trouv√©
     */
    onMatchFound(data) {
        this.battleState.isSearching = false;
        this.battleState.matchData = data;
        
        this.updateBattleButton();
        this.clearSearchTimer();
        
        this.showMatchFoundNotification(data);
        
        this.log(`Match trouv√© contre ${data.opponent?.username}`, 'success');
    }
    
    // üÜï CALLBACKS MATCHMAKING
    
    /**
     * Callback: Match trouv√© via matchmaking avanc√©
     */
    onAdvancedMatchFound(matchData) {
        this.log(`Match avanc√© trouv√©:`, matchData);
        
        // Nettoyer l'UI de matchmaking
        this.cleanupMatchmakingUI();
        
        // Afficher les d√©tails du match
        this.showAdvancedMatchFoundNotification(matchData);
    }
    
    /**
     * Callback: Mise √† jour du statut de matchmaking
     */
    onMatchmakingUpdate(updateData) {
        this.log(`Mise √† jour matchmaking:`, updateData);
        
        if (this.matchmakingElements && this.matchmakingElements.status) {
            const message = updateData.message || 'Recherche en cours...';
            this.matchmakingElements.status.setText(message);
        }
    }
    
    /**
     * Callback: Matchmaking annul√© par le serveur
     */
    onMatchmakingCancelled(reason) {
        this.log(`Matchmaking annul√©: ${reason}`, 'warn');
        
        this.cleanupMatchmakingUI();
        this.showError(`Matchmaking annul√©: ${reason}`);
    }

    // === NOTIFICATIONS ===
    
    /**
     * Afficher notification match trouv√©
     */
    showMatchFoundNotification(data) {
        const message = `üéØ Adversaire trouv√© !\n${data.opponent?.username || 'Joueur'}`;
        
        // Cr√©er notification temporaire
        const notification = this.createText(
            this.width / 2,
            this.height / 2,
            message,
            {
                fontSize: '18px',
                fontWeight: 'bold',
                fill: '#32CD32',
                align: 'center',
                backgroundColor: '#000000',
                padding: { x: 20, y: 10 }
            }
        );
        notification.setOrigin(0.5);
        
        // Animation d'apparition
        notification.setAlpha(0);
        notification.setScale(0.8);
        
        this.scene.tweens.add({
            targets: notification,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
            duration: 300,
            ease: 'Back.easeOut'
        });
        
        // Auto-suppression apr√®s 3 secondes
        this.scene.time.delayedCall(3000, () => {
            this.scene.tweens.add({
                targets: notification,
                alpha: 0,
                duration: 200,
                onComplete: () => notification.destroy()
            });
        });
    }
    
    /**
     * Afficher notification de match avanc√© trouv√©
     */
    showAdvancedMatchFoundNotification(matchData) {
        const opponentInfo = matchData.opponent || {};
        const estimatedWinRate = matchData.estimatedWinRate || 50;
        const matchQuality = matchData.matchQuality || 'Bon';
        
        const message = `üéØ Match optimal trouv√© !\n` +
                       `Adversaire: ${opponentInfo.username || 'Joueur'}\n` +
                       `Niveau: ${opponentInfo.level || '?'} | Troph√©es: ${opponentInfo.trophies || '?'}\n` +
                       `Qualit√©: ${matchQuality} | Chance de victoire: ${estimatedWinRate}%`;
        
        // Notification √©tendue
        const notification = this.createText(
            this.width / 2,
            this.height / 2,
            message,
            {
                fontSize: '14px',
                fontWeight: 'bold',
                fill: '#32CD32',
                align: 'center',
                backgroundColor: '#000000',
                padding: { x: 20, y: 15 }
            }
        );
        notification.setOrigin(0.5);
        notification.setDepth(2000);
        
        // Animation d'apparition
        notification.setAlpha(0);
        notification.setScale(0.8);
        
        this.scene.tweens.add({
            targets: notification,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
            duration: 400,
            ease: 'Back.easeOut'
        });
        
        // Auto-suppression apr√®s 5 secondes
        this.scene.time.delayedCall(5000, () => {
            this.scene.tweens.add({
                targets: notification,
                alpha: 0,
                duration: 300,
                onComplete: () => notification.destroy()
            });
        });
    }

    // === UTILITAIRES SP√âCIFIQUES ===
    
    /**
     * Mettre √† jour le bouton de bataille
     */
    updateBattleButton() {
        if (!this.battleElements.battleButton) return;
        
        // D√©truire l'ancien bouton
        this.battleElements.battleButton.destroy();
        
        // Recr√©er avec le bon √©tat
        this.battleElements.battleButton = this.createBattleMainButton();
        
        // Retrouver le container des boutons et l'ajouter
        const buttonsContainer = this.elements.content.list.find(child => 
            child.list && child.list.some(item => item === this.battleElements.battleButton)
        );
        
        if (buttonsContainer) {
            buttonsContainer.add(this.battleElements.battleButton);
        }
    }
    
    /**
     * Mettre √† jour l'√©tat des boutons
     */
    updateButtonStates() {
        // Activer/d√©sactiver les boutons selon l'√©tat
        const isDisabled = this.battleState.isSearching || this.battleState.isMatchmaking;
        
        // Mettre √† jour l'apparence du bouton matchmaking
        if (this.battleElements.matchmakingButton && this.battleState.isMatchmaking) {
            // Changer l'apparence pour indiquer que le matchmaking est actif
            this.scene.tweens.add({
                targets: this.battleElements.matchmakingButton,
                alpha: 0.6,
                duration: 200
            });
        } else if (this.battleElements.matchmakingButton) {
            this.scene.tweens.add({
                targets: this.battleElements.matchmakingButton,
                alpha: 1,
                duration: 200
            });
        }
        
        this.log(`Boutons ${isDisabled ? 'd√©sactiv√©s' : 'activ√©s'}`);
    }
    
    /**
     * Mettre √† jour les informations d'ar√®ne
     */
    updateArenaInfo() {
        const currentArena = this.getCurrentArena();
        
        if (this.realtimeElements.arenaName) {
            this.realtimeElements.arenaName.setText(currentArena.name);
        }
        
        this.updateProgressBar();
    }
    
    /**
     * Mettre √† jour la barre de progression
     */
    updateProgressBar() {
        if (!this.realtimeElements.progressBar) return;
        
        const currentTrophies = this.getUserData()?.playerStats?.trophies || 0;
        const currentArena = this.getCurrentArena();
        const nextArena = this.getNextArena();
        
        // Mettre √† jour le texte
        if (this.realtimeElements.trophyText) {
            const progressText = nextArena ? 
                `üèÜ ${currentTrophies}/${nextArena.minTrophies}` :
                `üèÜ ${currentTrophies} MAX`;
            this.realtimeElements.trophyText.setText(progressText);
        }
        
        // Redessiner la barre
        this.realtimeElements.progressBar.clear();
        
        if (nextArena) {
            const progressInArena = currentTrophies - currentArena.minTrophies;
            const totalArenaRange = nextArena.minTrophies - currentArena.minTrophies;
            const progressPercent = Math.min((progressInArena / totalArenaRange) * 100, 100);
            
            this.realtimeElements.progressBar.fillStyle(0xFFD700, 1);
            this.realtimeElements.progressBar.fillRoundedRect(
                this.width / 2 - 98, 107,
                (196 * progressPercent / 100),
                8,
                4
            );
        }
    }
    
    /**
     * Mettre √† jour le timer de recherche
     */
    updateSearchTimer() {
        if (!this.battleState.isSearching || !this.battleElements.searchTimer) {
            return;
        }
        
        const elapsed = Math.floor((Date.now() - this.battleState.searchStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        
        this.battleElements.searchTimer.setText(
            `‚è±Ô∏è Recherche: ${minutes}:${seconds.toString().padStart(2, '0')}`
        );
    }
    
    /**
     * Nettoyer le timer de recherche
     */
    clearSearchTimer() {
        if (this.searchTimerInterval) {
            clearInterval(this.searchTimerInterval);
            this.searchTimerInterval = null;
        }
        
        if (this.battleElements.searchTimer) {
            this.battleElements.searchTimer.destroy();
            this.battleElements.searchTimer = null;
        }
    }

    // === CONFIGURATION AR√àNE ===
    
    /**
     * Obtenir la configuration des ar√®nes
     */
    getArenaConfiguration() {
        return [
            {
                id: 0,
                name: 'Ar√®ne des Gobelins',
                displayName: 'Ar√®ne 1',
                minTrophies: 0,
                maxTrophies: 399,
                color: 0x8B4513,
                accentColor: 0xDAA520
            },
            {
                id: 1,
                name: 'Ar√®ne d\'Os',
                displayName: 'Ar√®ne 2',
                minTrophies: 400,
                maxTrophies: 799,
                color: 0x2F4F4F,
                accentColor: 0x708090
            },
            {
                id: 2,
                name: 'Ar√®ne PEKKA',
                displayName: 'Ar√®ne 3',
                minTrophies: 800,
                maxTrophies: 1199,
                color: 0x4B0082,
                accentColor: 0x8A2BE2
            },
            {
                id: 3,
                name: 'Ar√®ne Royale',
                displayName: 'Ar√®ne 4',
                minTrophies: 1200,
                maxTrophies: 1599,
                color: 0x9370DB,
                accentColor: 0xDDA0DD
            }
        ];
    }
    
    /**
     * Obtenir l'ar√®ne actuelle
     */
    getCurrentArena() {
        const currentTrophies = this.getUserData()?.playerStats?.trophies || 0;
        
        return this.arenaConfig.find(arena => 
            currentTrophies >= arena.minTrophies && currentTrophies <= arena.maxTrophies
        ) || this.arenaConfig[0];
    }
    
    /**
     * Obtenir l'ar√®ne suivante
     */
    getNextArena() {
        const currentTrophies = this.getUserData()?.playerStats?.trophies || 0;
        
        return this.arenaConfig.find(arena => 
            arena.minTrophies > currentTrophies
        ) || null;
    }
    
    /**
     * Mettre √† jour les statistiques de bataille
     */
    updateBattleStats() {
        // Recalculer et afficher les nouvelles stats
        if (!this.isMobile) {
            this.log('Mise √† jour stats bataille');
        }
    }
    
    /**
     * V√©rifier si Colyseus est connect√©
     */
    isColyseusConnected() {
        // Pour l'instant, on simule avec l'indicateur visuel
        return this.realtimeElements.connectionStatus?.text === 'üü¢';
    }

    // === MISE √Ä JOUR DEPUIS COLYSEUS ===
    
    /**
     * Mettre √† jour depuis les donn√©es temps r√©el
     */
    updateFromRealtimeData(realtimeData) {
        this.log('Mise √† jour depuis donn√©es temps r√©el');
        
        // Mettre √† jour les troph√©es
        if (realtimeData.trophies !== undefined) {
            this.updateProgressBar();
        }
        
        // Mettre √† jour l'ar√®ne
        if (realtimeData.currentArena) {
            this.updateArenaInfo();
        }
        
        // Mettre √† jour les stats de bataille
        if (realtimeData.gameStats) {
            this.updateBattleStats();
        }
    }
    
    /**
     * G√©rer le r√©sultat d'une bataille
     */
    onBattleResult(result) {
        this.log(`R√©sultat bataille: ${result.victory ? 'Victoire' : 'D√©faite'}`);
        
        // Mettre √† jour l'√©tat
        this.battleState.isSearching = false;
        this.battleState.isMatchmaking = false;
        this.battleState.matchData = null;
        
        // Nettoyer l'UI
        this.updateBattleButton();
        this.clearSearchTimer();
        this.cleanupMatchmakingUI();
        
        // Afficher le r√©sultat
        const message = result.victory ? 
            `üéâ Victoire ! +${result.trophyChange} troph√©es` :
            `üòû D√©faite ! ${result.trophyChange} troph√©es`;
            
        this.showBattleResult(message, result.victory);
        
        // V√©rifier changement d'ar√®ne
        if (result.arenaChanged) {
            this.showArenaUnlocked(result.newArena);
        }
        
        // Rafra√Æchir les donn√©es
        this.refresh();
    }
    
    /**
     * Afficher le r√©sultat d'une bataille
     */
    showBattleResult(message, isVictory) {
        const color = isVictory ? '#32CD32' : '#DC143C';
        const icon = isVictory ? 'üéâ' : 'üòû';
        
        // Cr√©er notification de r√©sultat
        const resultBg = this.createGraphics();
        resultBg.fillStyle(isVictory ? 0x006400 : 0x8B0000, 0.9);
        resultBg.fillRoundedRect(20, this.height / 2 - 40, this.width - 40, 80, 15);
        
        const resultText = this.createText(
            this.width / 2,
            this.height / 2,
            `${icon} ${message}`,
            {
                fontSize: '16px',
                fontWeight: 'bold',
                fill: '#FFFFFF',
                align: 'center'
            }
        );
        resultText.setOrigin(0.5);
        
        // Animation d'entr√©e
        resultBg.setAlpha(0);
        resultText.setAlpha(0);
        
        this.scene.tweens.add({
            targets: [resultBg, resultText],
            alpha: 1,
            duration: 300,
            ease: 'Back.easeOut'
        });
        
        // Auto-suppression apr√®s 4 secondes
        this.scene.time.delayedCall(4000, () => {
            this.scene.tweens.add({
                targets: [resultBg, resultText],
                alpha: 0,
                duration: 300,
                onComplete: () => {
                    resultBg.destroy();
                    resultText.destroy();
                }
            });
        });
    }
    
    /**
     * Afficher notification nouvelle ar√®ne
     */
    showArenaUnlocked(newArena) {
        const message = `üèüÔ∏è Nouvelle ar√®ne d√©bloqu√©e !\n${newArena.name}`;
        
        // Animation sp√©ciale pour nouvelle ar√®ne
        const unlockNotification = this.createText(
            this.width / 2,
            this.height / 2 - 60,
            message,
            {
                fontSize: '18px',
                fontWeight: 'bold',
                fill: '#FFD700',
                align: 'center',
                stroke: '#8B4513',
                strokeThickness: 2
            }
        );
        unlockNotification.setOrigin(0.5);
        
        // Effet de particules dor√©es
        this.createGoldenParticles(this.width / 2, this.height / 2 - 60);
        
        // Animation pulsante
        this.pulse(unlockNotification, 800);
        
        // Auto-suppression apr√®s 5 secondes
        this.scene.time.delayedCall(5000, () => {
            unlockNotification.destroy();
        });
    }
    
    /**
     * Cr√©er effet de particules dor√©es
     */
    createGoldenParticles(x, y) {
        const particleCount = 12;
        
        for (let i = 0; i < particleCount; i++) {
            const particle = this.createGraphics();
            particle.fillStyle(0xFFD700, 0.8);
            particle.fillCircle(x, y, 4);
            
            const angle = (Math.PI * 2 / particleCount) * i;
            const distance = 60;
            
            this.scene.tweens.add({
                targets: particle,
                x: x + Math.cos(angle) * distance,
                y: y + Math.sin(angle) * distance,
                alpha: 0,
                scaleX: 0.3,
                scaleY: 0.3,
                duration: 1000,
                ease: 'Power2.easeOut',
                onComplete: () => particle.destroy()
            });
        }
    }

    // === GESTION DES √âV√âNEMENTS ===
    
    /**
     * G√©rer l'activation du panel
     */
    onPanelActivated() {
        this.log('Panel bataille activ√©');
        
        // Rafra√Æchir les donn√©es
        this.refresh();
        
        // Relancer les animations si n√©cessaire
        if (this.battleState.isSearching) {
            this.updateBattleButton();
        }
        
        if (this.battleState.isMatchmaking) {
            this.addMatchmakingButtonEffects();
        }
    }
    
    /**
     * G√©rer la d√©sactivation du panel
     */
    onPanelDeactivated() {
        this.log('Panel bataille d√©sactiv√©');
        
        // Nettoyer les timers
        this.clearSearchTimer();
        
        if (this.matchmakingTimeInterval) {
            clearInterval(this.matchmakingTimeInterval);
            this.matchmakingTimeInterval = null;
        }
    }

    // === NETTOYAGE ===
    
    /**
     * Nettoyer les ressources du panel
     */
    destroy() {
        this.log('Destruction panel bataille');
        
        // Nettoyer les timers
        this.clearSearchTimer();
        
        if (this.matchmakingTimeInterval) {
            clearInterval(this.matchmakingTimeInterval);
            this.matchmakingTimeInterval = null;
        }
        
        // üÜï Nettoyer le matchmaking
        this.cleanupMatchmakingUI();
        
        // Nettoyer les r√©f√©rences
        Object.keys(this.battleElements).forEach(key => {
            this.battleElements[key] = null;
        });
        
        Object.keys(this.realtimeElements).forEach(key => {
            this.realtimeElements[key] = null;
        });
        
        // Appeler le nettoyage parent
        super.destroy();
    }

    // === M√âTHODES PUBLIQUES POUR INT√âGRATION ===
    
    /**
     * API publique pour la sc√®ne parent
     */
    
    // Connexion Colyseus
    setColyseusConnected(connected) {
        if (connected) {
            this.onColyseusConnected();
        } else {
            this.onColyseusDisconnected();
        }
    }
    
    // Mise √† jour stats globales
    updateGlobalStats(stats) {
        this.onGlobalStatsUpdated(stats);
    }
    
    // √âtat de recherche
    setSearchState(isSearching, data = null) {
        if (isSearching) {
            this.onSearchStarted(data);
        } else {
            this.onSearchCancelled(data);
        }
    }
    
    // Match trouv√©
    notifyMatchFound(matchData) {
        this.onMatchFound(matchData);
    }
    
    // üÜï Match avanc√© trouv√©
    notifyAdvancedMatchFound(matchData) {
        this.onAdvancedMatchFound(matchData);
    }
    
    // üÜï Mise √† jour matchmaking
    notifyMatchmakingUpdate(updateData) {
        this.onMatchmakingUpdate(updateData);
    }
    
    // üÜï Matchmaking annul√©
    notifyMatchmakingCancelled(reason) {
        this.onMatchmakingCancelled(reason);
    }
    
    // R√©sultat bataille
    notifyBattleResult(result) {
        this.onBattleResult(result);
    }
    
    // Mise √† jour profil temps r√©el
    updateRealtimeProfile(profile) {
        this.updateFromRealtimeData(profile);
    }
    
    // üÜï Forcer l'arr√™t du matchmaking depuis l'ext√©rieur
    stopMatchmaking() {
        if (this.battleState.isMatchmaking) {
            this.handleCancelMatchmaking();
        }
    }
    
    // üÜï Obtenir l'√©tat du matchmaking
    getMatchmakingState() {
        return {
            isActive: this.battleState.isMatchmaking,
            hasUI: !!this.matchmakingElements,
            startTime: this.matchmakingElements?.startTime || null,
            timestamp: Date.now()
        };
    }

    // === GETTERS POUR DEBUG ===
    
    getBattleState() {
        return { ...this.battleState };
    }
    
    getArenaConfig() {
        return [...this.arenaConfig];
    }
    
    isSearching() {
        return this.battleState.isSearching;
    }
    
    // üÜï √âtat matchmaking
    isMatchmaking() {
        return this.battleState.isMatchmaking;
    }
    
    hasActiveSearch() {
        return this.battleState.isSearching || this.battleState.isMatchmaking;
    }
}
